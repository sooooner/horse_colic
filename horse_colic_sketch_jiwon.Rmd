---
title: "horse_colic_stetch"
author: "JW"
date: "2018년 7월 22일"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 데이터 불러오기
```{r}
horse <- read.csv('../horse_colic/horse.csv', header = T, stringsAsFactors = F)

head(horse)

summary(horse)

unique(horse$outcome)

## statistics of died, lived, euthanized
dead <- horse[horse$outcome=="died",]
euthanized <- horse[horse$outcome=="euthanized",]
lived <- horse[horse$outcome=="lived",]

summary(dead)
summary(euthanized)
summary(lived)

library(ggplot2)
library(reshape2)
library(ggplot2)
library(plyr)
library(gridExtra)
```



## data exploration
```{r}
summary(horse)

# 연속형, 범주형 변수 분리
linear.horse <- horse[,c(4,5,6,16,19,20,22,23)]
head(linear.horse)
categorical.horse <- horse[,c(1,2,7:15,17,23)]
head(categorical.horse)


# 변수 이름 저장
name.of.categorical.horse <- names(categorical.horse)
name.of.linear.horse <- names(linear.horse)

length(name.of.categorical.horse)
length(name.of.linear.horse)

# value 담을 list
horse.value.list.l <- vector("list", length = 6)
horse.value.list.c <- vector("list", length = 12)
horse.graph.list <- vector("list", length = 12)
horse.graph.list.l <- vector("list", length = 6)
horse.freq.list <- vector("list", length = 12)

# unique 수치 list에 담음
# for(i in 1:12){
# horse.value.list[[i]] <- unique(categorical.horse[,i])
# }

# 각 변수 분리해 list에 담음(그래프 그리기 위해)
for(i in 1:12){
horse.value.list.c[[i]] <- categorical.horse[,c(13,i)]
}
for(i in 1:7){
horse.value.list.l[[i]] <- linear.horse[,c(8,i)]
}
horse.value.list.l[[1]]
names(horse.value.list.c) <- name.of.categorical.horse[1:12]
names(horse.value.list.l) <- name.of.categorical.horse[1:7]


# 변수 이름 변경
for(i in 1:12){
colnames(horse.value.list.c[[i]]) <- c('variable', 'outcome')}
for(i in 1:7){
colnames(horse.value.list.l[[i]]) <- c('outcome', 'variable')}

# outcome과 변수별 frequency 알아보기
for(i in 1:12){
  horse.freq.list[[i]] <- ddply(horse.value.list.c[[i]], names(horse.value.list.c[[i]]), summarise, Freq=length(variable))
}
horse.freq.list[[1]]

## graph of categorical data
scale_count <- c("died", "euthanized", "lived")
scale_rep <- c("1","2","3")
names(scale_count) <- scale_rep
```

## 그래프 그리기
```{r}
## 범주형 변수
# 리스트에 담기
for(i in 1:12){
horse.graph.list[[i]] <- ggplot(horse.freq.list[[i]], aes(x=variable, y=outcome)) +
  geom_tile(aes(fill=Freq)) + labs(y = name.of.categorical.horse[i], x = "outcome")
}

for(i in 1:7){
horse.graph.list.l[[i]] <- ggplot(horse.value.list.l[[i]], aes(x=outcome, y=variable, fill=outcome)) + geom_boxplot() + labs(y = name.of.linear.horse[i], x = "outcome") + scale_fill_discrete(guide=FALSE)
}


# 식별 편하도록 리스트에 이름 부여
names(horse.graph.list) <- name.of.categorical.horse[1:12]
names(horse.graph.list.l) <- name.of.linear.horse[1:7]

ggplot(horse.value.list.l[[1]], aes(x=outcome, y=variable, fill=outcome)) + geom_boxplot() + scale_fill_discrete(guide=FALSE)



# 그래프 한번에 모아보기
do.call(grid.arrange,horse.graph.list)
do.call(grid.arrange,horse.graph.list.l[[2]],horse.graph.list.l[[4]])

horse.freq.list[[12]]

```

## Missing Value Map
```{r}
install.packages("Amelia")
library(Amelia)

missmap(linear.horse[,1:7])



freq <-  ddply(long, names(surgery), summarise, Freq=length(variable))

for(i in 1:12){
horse.freq.list2 <- 
  horse.freq.list[[i]]$name <- name.of.categorical.horse[[i]]
}

freq <- do.call(rbind, horse.freq.list)
head(freq)

library(dplyr)
freq.percent <- group_by(freq, name) %>% mutate(percent = round(Freq*100/sum(Freq),1))

freq.percent2 <- group_by(freq, name) %>% transmute(variable, percent = round(Freq*100/sum(Freq),1))

head(freq.percent2)
View(freq.percent)

```
# 데이터가 변수의 특성을 잘 나타내는지 확인
```{r}
# obstruction: nasogastic reflux, rectal examination fces, abdomen, abdominocentesis appearance, abdomcentesis total protein
# dehydration: packed cell volume, total protein
# gut activity: peristalsis, abdominal distension
# shock: rectal temperature, temperature of extremities, mucous membrances, pulse
# pain: pulse, pain
# circulation: mucous membrane, capillary refill time, peripheral pulse

```


## 변수별 관련성 이용하여 NA 채워넣기
```{r}
## predict dehydration
unique(horse$packed_cell_volume)
horse$packed_cell_volume2 <- ifelse(horse$packed_cell_volume>50, "dehyd",ifelse(horse$packed_cell_volume>=30&horse$packed_cell_volume<=50,"normal","others"))

unique(horse$total_protein)
horse$total_protein2 <- ifelse(horse$total_protein>7.6, "dehyd",ifelse(horse$total_protein>=6&horse$total_protein<=7.6,"normal","others"))

dehyd <- cbind(horse$packed_cell_volume2, horse$total_protein2, horse$packed_cell_volume, horse$total_protein)

head(dehyd)

## obstruction
unique(horse$nasogastric_reflux)
horse$nasogastric_reflux2 <- ifelse(horse$nasogastric_reflux=="more_1_liter", "obs",ifelse(horse$nasogastric_reflux=="less_1_liter","a.little","normal"))

unique(horse$nasogastric_reflux_ph)
horse$nasogastric_reflux_ph2 <- ifelse(horse$nasogastric_reflux_ph>=3&horse$nasogastric_reflux_ph<=4, "normal","abnormal")


unique(horse$rectal_exam_feces)
horse$rectal_exam_feces2 <- ifelse(horse$rectal_exam_feces=="absent", "obs",ifelse(horse$rectal_exam_feces=="normal","normal","other"))
unique(horse$rectal_exam_feces2)

unique(horse$abdomo_appearance)
horse$abdomo_appearance2 <- ifelse(horse$abdomo_appearance=="cloudy"|horse$abdomo_appearance=="serosanguious", "obs","normal")

obs <- cbind(horse$nasogastric_reflux2,
             horse$rectal_exam_feces2,
             horse$abdomo_appearance2,
             horse$abdomo_protein,
             horse$nasogastric_reflux,
             horse$rectal_exam_feces,
             horse$abdomo_appearance)
head(obs)
obs <- as.data.frame(obs)

## rectal_temp와 temp_of_extremity간의 선형관계 알아보기
## 관련성 이용하여 NA 채워넣기 
temp <- cbind(horse$rectal_temp, horse$temp_of_extremities)
head(temp)

## gut activity(peristalsis, abdominal_distention)
gut <- cbind(horse$peristalsis, horse$abdominal_distention)
head(gut)

```

## Missing data
```{r}
# 출처: https://rstudio-pubs-static.s3.amazonaws.com/192402_012091b9adac42dbbd22c4d07cb00d36.html

require(moonBook)

na.count=apply(linear.horse, 2, function(x) sum(is.na(x)))
na.chart <- na.count[na.count>0]
na.chart <- as.data.frame(na.chart)
na.chart <- t(na.chart)
na.chart
##추후 옵션변
ggplot(na.chart) + barplot(aes(x="continuous variable", y="count"))
barplot(na.chart)

install.packages("VIM")
require(VIM)
require(robustbase)

x = as.data.frame(abs(is.na(linear.horse)))
y=apply(x,2,function(x) sum(x)>0)
View(round(cor(x[y]),2))

nrow(linear.horse)
linear.horse2 <- na.omit(linear.horse)
nrow(linear.horse2)

dehydrated <- linear.horse[,c(5,6)]
dehydrated2 <- linear.horse[,c(5,6)]
cor.test(dehydrated2$packed_cell_volume, dehydrated2$total_protein, method ='spearman')
dehydrated2 <- na.omit(dehydrated2)
nrow(dehydrated)
colnames(dehydrated)
#kendall, spearman
cor.test(dehydrated$packed_cell_volume, dehydrated$total_protein, method = "spearman")

shapiro.test(dehydrated$packed_cell_volume)
shapiro.test(dehydrated$total_protein)

# install.packages("ggpubr")
library("ggpubr")
ggqqplot(dehydrated$packed_cell_volume, ylab = "packed cell volume")
ggqqplot(dehydrated$total_protein, ylab = "total protein")
View(dehydrated)

write.csv(dehydrated, "cor.csv")

library(data.table)
set.seed(123)
#install.packages("corrplot")
library(corrplot)
corrplot(linear.horse)
#install.packages("Hmisc")
library(Hmisc)
res <- rcorr(as.matrix(linear.horse[,1:7]))
res2 <- rcorr(as.matrix(categorical.horse[,1:12]))
View(res)
flattenCorrMatrix <- function(cormat, pmat) {
  ut <- upper.tri(cormat)
  data.frame(
    row = rownames(cormat)[row(cormat)[ut]],
    column = rownames(cormat)[col(cormat)[ut]],
    cor  =(cormat)[ut],
    p = pmat[ut]
    )
}
flattenCorrMatrix(res$r, res$P)

rho <- cor.test(dehydrated2$packed_cell_volume, dehydrated2$total_protein, method = 'spearman')
rho <- rho$estimate
# linear regression of original data
fit1 <- lm(packed_cell_volume ~ total_protein, data = dehydrated)
fit2 <- lm(total_protein ~ packed_cell_volume, data = dehydrated)

# standard errors of regression intercept
# multiply se by sqrt to get sd
sd1 = summary(fit1)$coefficients[1,2] * sqrt(dehydrated[!is.na(dehydrated$packed_cell_volume), .N])
sd2 = summary(fit2)$coefficients[1,2] * sqrt(dehydrated[!is.na(dehydrated$total_protein), .N])

# find where data points with missing values lie on the regression line
dehydrated <- data.table(dehydrated)
dehydrated[is.na(packed_cell_volume), packed_cell_volume.imp := coefficients(fit1)[1] + coefficients(fit1)[2] * total_protein] 
dehydrated[is.na(dehydrated$total_protein), total_protein.imp := coefficients(fit2)[1] + coefficients(fit2)[2] * packed_cell_volume]

# generate randomised residuals for the missing data, using the s.d. calculated above
dehydrated[is.na(packed_cell_volume), packed_cell_volume.ran := rnorm(.N, sd=sd1)] 
dehydrated[is.na(total_protein), total_protein.ran := rnorm(.N, sd=sd2)]

# function that scales the residuals by a factor x, then calculates how close correlation of imputed data is to that of original data
obj = function(x, dehydrated, rho) {
  dehydrated[, packed_cell_volume.comp := packed_cell_volume][, total_protein.comp := total_protein]
  dehydrated[is.na(packed_cell_volume), packed_cell_volume.comp := packed_cell_volume.imp + packed_cell_volume.ran*x] 
  dehydrated[is.na(total_protein), total_protein.comp := total_protein.imp + total_protein.ran*x] 
  rho2 = cor(dehydrated$total_protein.comp, dehydrated$packed_cell_volume.comp,'pairwise')
  (rho-rho2)^2
}

# find the value of x that minimises the discrepencay of imputed versus original correlation
fit = optimize(obj, c(-5,5), dehydrated, rho)


x=fit$minimum
dehydrated[, packed_cell_volume.comp := packed_cell_volume][, total_protein.comp := total_protein]
dehydrated[is.na(packed_cell_volume), packed_cell_volume.comp := packed_cell_volume.imp + packed_cell_volume.ran*x] 
dehydrated[is.na(total_protein), total_protein.comp := total_protein.imp + total_protein.ran*x] 
rho2 = cor(dehydrated$total_protein.comp, dehydrated$packed_cell_volume.comp,'pairwise')
(rho-rho2)^2  # check that rho2 is approximately equal to rho

fit.comp = lm(packed_cell_volume.comp ~ total_protein.comp, data=dehydrated)

plot(dehydrated$total_protein.comp, dehydrated$total_protein.comp)
points(dehydrated$total_protein, dehydrated$total_protein, col="red")
abline(fit1, col="green")
abline(fit.comp, col = "blue")
mtext(paste(" Rho =", round(rho, 5)), at=-1)
mtext(paste(" Rho2 =", round(rho2, 5)), at=6)
```

```{r}
cor.test(linear.horse$total_protein, linear.horse$nasogastric_reflux_ph,  method = "pearson", use = "complete.obs")

require(lattice)
pairs(linear.horse[,c("total_protein", "nasogastric_reflux_ph")])

names(linear.horse)

# 등분산성 확인
var.test(na.omit(linear.horse[linear.horse$outcome=="lived",4]), na.omit(linear.horse[linear.horse$outcome=="died",4]))

t.test(na.omit(linear.horse[linear.horse$outcome=="lived",4]), na.omit(linear.horse[linear.horse$outcome=="died",4]),  paired = FALSE, var.equal = TRUE, conf.level = 0.95)

t.test(na.omit(linear.horse[linear.horse$outcome=="lived",7]), na.omit(linear.horse[linear.horse$outcome=="died",7]),  paired = FALSE, var.equal = TRUE, conf.level = 0.95)

t.test(na.omit(linear.horse[linear.horse$outcome=="lived",1]), na.omit(linear.horse[linear.horse$outcome=="died",1]),  paired = FALSE, var.equal = TRUE, conf.level = 0.95)

horse.logit <- read.csv('C:/Users/Smart User/Desktop/naver_competition/data-files/horse.logit.csv', header = T, stringsAsFactors = F)

horse.logit2 <- read.csv('C:/Users/Smart User/Desktop/naver_competition/data-files/horse_na.csv', header = T, stringsAsFactors = F)


head(horse.logit)

install.packages("mice")
library(mice)

md.pattern(horse.logit)
p <- md.pairs(horse.logit2)
p

imp <- mice(horse.logit)
head(horse.logit2)
imp

complete(imp2)

horse.logit.glm <- glm(outcome ~ ., family=binomial(link = "logit"), data = complete(imp))

summary(horse.logit.glm)

step(horse.logit.glm)
```

